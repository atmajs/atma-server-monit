// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../@slack/web-api
//   ../atma-io

declare module 'everlog' {
    export { Monit } from 'everlog/Monit';
    export { Everlog } from 'everlog/Everlog';
}

declare module 'everlog/Monit' {
    import { IMonitOptions } from 'everlog/MonitWorker';
    import { ILoggerOpts, LoggerFile, ILogger } from 'everlog/fs/LoggerFile';
    type Application = any;
    export namespace Monit {
        function startLogger(opts: IMonitOptions): Promise<void>;
        function start(app: Application, opts: IMonitOptions): void;
        function createChannel(name: string, opts?: Partial<ILoggerOpts>): ILogger;
        function createChannelReader(channel: LoggerFile): any;
        function createChannelReader(name: string, opts?: Partial<ILoggerOpts>): any;
        function flush(): void;
        function error(error: Error): void;
    }
    export {};
}

declare module 'everlog/Everlog' {
    import { MonitWorker, IMonitOptions } from 'everlog/MonitWorker';
    import { ILoggerOpts, LoggerFile, ILogger } from 'everlog/fs/LoggerFile';
    export namespace Everlog {
        let monit: MonitWorker;
        function initialize(opts: IMonitOptions): Promise<MonitWorker>;
        function createChannel(name: string, opts?: Partial<ILoggerOpts>): ILogger;
        function createChannelReader(channel: LoggerFile): any;
        function createChannelReader(name: string, opts?: Partial<ILoggerOpts>): any;
        function flush(): void;
        function error(error: Error): void;
    }
}

declare module 'everlog/MonitWorker' {
    import { SlackClient } from 'everlog/Slack';
    import { LoggerFile, ILoggerOpts } from 'everlog/fs/LoggerFile';
    import { ChannelReader } from 'everlog/reader/ChannelReader';
    type LifecycleEvent = any;
    type LifecycleEvents = any;
    export interface IMonitOptions {
        directory?: string;
        channels?: {
            [name: string]: ILoggerOpts;
        };
        slack?: {
            token: string;
            channelId: string;
        };
        filterForSlack?: (event: LifecycleEvent) => boolean;
    }
    export class MonitWorker {
        opts: IMonitOptions & {
            disableDefaultLoggers?: boolean;
        };
        slack: SlackClient;
        loggers: {
            start?: LoggerFile;
            requests?: LoggerFile;
            errors?: LoggerFile;
            [name: string]: LoggerFile;
        };
        constructor(opts: IMonitOptions & {
            disableDefaultLoggers?: boolean;
        });
        createChannel(name: string, opts?: Partial<ILoggerOpts>): LoggerFile;
        createChannelReader(channel: LoggerFile): ChannelReader;
        /** Bind Watcher (Requests/Errors) to Atma server Application  */
        watchServer(events: LifecycleEvents): void;
        writeError(error: Error): void;
        /** Flush all buffered content to disk */
        flush(): void;
        restoreChannelsAsync(): Promise<void>;
    }
    export {};
}

declare module 'everlog/fs/LoggerFile' {
    import { ICsvColumn, ICsvColumnValue, ICsvDictionary } from 'everlog/model/ICsvColumn';
    export interface ILoggerOpts {
        directory: string;
        fileCountMax?: number;
        fileBytesMax?: number;
        fileMessagesMax?: number;
        messageBufferMax?: number;
        writeTimeout?: number;
        fields?: ICsvColumn[];
        addCsvHeader?: boolean;
        columns?: ICsvColumn[];
    }
    export interface ILogger {
        writeRow(cells: any[], additional?: (ICsvColumn & {
            value: any;
        })[]): any;
        write(mix: string | any[]): void;
        flush(): any;
        removeAll(): Promise<any>;
    }
    export class EmptyLoggerFile implements ILogger {
        name: any;
        opts: any;
        constructor(name: any, opts: any);
        writeRow(...args: Parameters<ILogger['writeRow']>): any;
        write(...args: Parameters<ILogger['write']>): void;
        flush(): any;
        removeAll(): Promise<any>;
        pipe(channel: ILogger): void;
    }
    export class LoggerFile implements ILogger {
        directory: string;
        opts: ILoggerOpts;
        static create(key: string, opts: ILoggerOpts): LoggerFile;
        static prepair(opts: ILoggerOpts): LoggerFile;
        static restore(directory: string, key: string, options?: ILoggerOpts): Promise<LoggerFile>;
        protected constructor(opts: ILoggerOpts);
        writeRow(cells: any[], additional?: ICsvDictionary | ICsvColumnValue[]): void;
        writeRows(cellsMany: any[][]): void;
        write(mix: string | any[]): void;
        get path(): string;
        flush(): void;
        removeAll(): Promise<any>;
        protected initOptions(opts: ILoggerOpts): void;
        protected init(): void;
    }
}

declare module 'everlog/Slack' {
    import { WebClient } from '@slack/web-api';
    export class SlackClient {
        access_token: string;
        team_id: string;
        enterprise_id: string;
        web: WebClient;
        token: string;
        channelId: string;
        constructor(opts: {
            token: string;
            channelId: string;
        });
        login(): Promise<void>;
        send(message: string): Promise<void>;
    }
}

declare module 'everlog/reader/ChannelReader' {
    import { FileReader } from 'everlog/reader/FileReader'; 
     import { LoggerFile } from 'everlog/fs/LoggerFile';
    import { ICsvColumn } from 'everlog/model/ICsvColumn';
    import { GetChannelParams } from 'everlog/reader/LogsReader';
    export interface IChannelLinesQuery {
            offset?: number;
            limit?: number;
            from?: Date;
            to?: Date;
    }
    export class ChannelReader {
            channel: LoggerFile;
            constructor(channel: LoggerFile);
            fetch(query?: IChannelLinesQuery): Promise<{
                    rows: any[];
            }>;
            getDays(): Promise<{
                    day: string;
            }[]>;
            getData(query: GetChannelParams): Promise<{
                    columns: ICsvColumn[];
                    rows: any[][];
                    size: number;
            }>;
            stats(): Promise<{
                    files: number;
                    lines: number;
            }>;
            protected getReaders(): Promise<FileReader[]>;
    }
}

declare module 'everlog/model/ICsvColumn' {
    export interface ICsvColumn {
        idx?: number;
        name: string;
        type?: 'string' | 'number' | 'date' | 'text' | 'boolean';
        summable?: boolean;
        groupable?: boolean;
        sortable?: boolean;
        filterable?: boolean;
    }
    export interface ICsvColumnValue extends ICsvColumn {
        value: any;
    }
    export interface ICsvDictionary {
        [name: string]: any;
    }
}

declare module 'everlog/reader/FileReader' {
    import { File } from 'atma-io';
    import { DayDate } from 'everlog/model/DayDate';
    import { LoggerFile } from 'everlog/fs/LoggerFile';
    import { ICsvColumn } from "everlog/model/ICsvColumn";
    type FileType = InstanceType<typeof File>;
    export interface IFileQuery {
        offset?: number;
        limit?: number;
        from?: Date;
        to?: Date;
    }
    export class FileReader {
        channel: LoggerFile;
        uri: string;
        idxFile?: FileType;
        day: DayDate;
        nr: number;
        fields: ICsvColumn[];
        cached: boolean;
        table: any[][];
        hasHeader: boolean;
        static create(channel: LoggerFile, uri: string, idxFile?: FileType): FileReader;
        protected constructor(channel: LoggerFile, uri: string, idxFile?: FileType);
        read(): Promise<any[][]>;
        fetch(opts: IFileQuery): Promise<{
            total: number;
            rows: any[][];
        }>;
        stats(): Promise<{
            lines: number;
        }>;
    }
    export namespace Csv {
        function detectFields(row: string[]): {
            type: any;
            name: string;
        }[];
        function parseType(val: string, field: ICsvColumn): string | number | Date;
        function splitRow(row: string): any[];
    }
    export {};
}

declare module 'everlog/reader/LogsReader' {
    import { ICsvColumn } from 'everlog/model/ICsvColumn'; 
     import { MonitWorker } from 'everlog/MonitWorker';
    import { ITableColumnFilter } from 'everlog/model/Table';
    import { DayDate } from 'everlog/model/DayDate';
    export class LogsReader {
            monit: MonitWorker;
            constructor(monit: MonitWorker);
            getChannels(): {
                    name: string;
                    directory: string;
                    columns: ICsvColumn[];
            }[];
            getChannelInfo(key: string): {
                    name: string;
                    directory: string;
                    columns: ICsvColumn[];
            };
            getChannelStats(key: string): Promise<{
                    files: number;
                    lines: number;
            }>;
            getChannelDays(key: string): Promise<{
                    day: string;
            }[]>;
            getChannelData(query: GetChannelParams): Promise<{
                    columns: ICsvColumn[];
                    rows: any[][];
                    size: number;
            }>;
    }
    export class GetChannelParams {
            key: string;
            sortByColumnIdx?: number;
            sortDir?: 'asc' | 'desc';
            columnFilters?: ITableColumnFilter[];
            day?: DayDate;
            rangeStart?: Date;
            rangeEnd?: Date;
            offset?: number;
            limit?: number;
    }
}

declare module 'everlog/model/DayDate' {
    export class DayDate implements IDay {
        year: number;
        date: number;
        month: number;
        constructor(year: number, month: number, date: number);
        constructor(str: string);
        constructor(day: IDay);
        constructor(date: Date);
        toDate(): Date;
        isEqual(date: DayDate): boolean;
        isSame(date: Date): boolean;
        isAfter(date: Date): boolean;
        isBefore(date: Date): boolean;
        valueOf(): number;
        format(pattern: any): any;
        serialize(): string;
        getFullYear(): number;
        getMonth(): number;
        getDate(): number;
        getHours(): number;
        getMinutes(): number;
        getSeconds(): number;
        static now(): DayDate;
    }
    export interface IDay {
        year: number;
        date: number;
        month: number;
    }
}

declare module 'everlog/model/Table' {
    import { ICsvColumn } from 'everlog/model/ICsvColumn';
    export interface ITableQuery {
        sortByColumnIdx?: number;
        sortDir?: 'asc' | 'desc';
        columnFilters?: ITableColumnFilter[];
        rangeStart?: Date;
        rangeEnd?: Date;
        offset?: number;
        limit?: number;
    }
    export interface ITableColumnFilter {
        columnIdx: number;
        q: string;
    }
    export class Table {
        rows: any[][];
        dateIdx: number;
        size: number;
        constructor(fields: ICsvColumn[], rows: any[][]);
        getTable(params: ITableQuery): any[][];
    }
}

